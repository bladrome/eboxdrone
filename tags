!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCZ_TILT_MAX	imu.cpp	132;"	d	file:
ACC_CALC_TIME	imu.h	13;"	d
ACC_SCALE	imu.cpp	106;"	d	file:
ANGLE_MAX	rc.h	7;"	d
Angle_control	eboxcopter.cpp	/^void Angle_control(void)$/;"	f
CHANNELS	rc.h	9;"	d
CHECK_TIME	imu.cpp	133;"	d	file:
CONSTANTS_G	imu.h	7;"	d
Cut_deadband	rc.cpp	/^double Cut_deadband(double from, double to, double deadband)$/;"	f
DCMgb	imu.h	/^		float   DCMgb[3][3];$/;"	m	struct:imu_tt
DEADBAND	rc.h	6;"	d
Data2angle	rc.cpp	/^void Data2angle(void)$/;"	f
EBOXCOPTER_H	eboxcopter.h	2;"	d
ELPF	filter.cpp	/^ELPF::ELPF(double sample_freq, double cutoff_freq)$/;"	f	class:ELPF
ELPF	filter.h	/^class ELPF$/;"	c
EPID	pidcontroller.cpp	/^EPID::EPID(double kp, double ki, double kd)$/;"	f	class:EPID
EPID	pidcontroller.cpp	/^EPID::EPID(double setpoint, double kp, double ki, double kd)$/;"	f	class:EPID
EPID	pidcontroller.h	/^class EPID$/;"	c
ESTIMATE_H	estimate.h	2;"	d
FILTER_H	filter.h	2;"	d
GYRO_CALC_TIME	imu.h	14;"	d
GYRO_SCALE	imu.cpp	107;"	d	file:
Get_pulse	rc.cpp	/^uint32_t Get_pulse(uint8_t channel)$/;"	f
IMU_CUTOFF_FREQ	imu.h	10;"	d
IMU_H_	imu.h	2;"	d
IMU_SAMPLE_FREQ	imu.h	9;"	d
IMU_calibrate	imu.cpp	/^uint8_t IMU_calibrate(void)$/;"	f
IMU_calibrate_tmp	imu.cpp	/^uint8_t IMU_calibrate_tmp(void)$/;"	f
IMU_check	imu.cpp	/^uint8_t IMU_check(void)$/;"	f
IMU_esti_init	estimate.cpp	/^static void IMU_esti_init(float ax, float ay, float az, float mx, float my, float mz)$/;"	f	file:
IMU_esti_update	estimate.cpp	/^static void IMU_esti_update(float gx, float gy, float gz, float ax, float ay, float az, float mx, float my, float mz, float twoKp, float twoKi, float dt) $/;"	f	file:
IMU_estimate	estimate.cpp	/^void IMU_estimate(void)$/;"	f
IMU_init	imu.cpp	/^void IMU_init(void)$/;"	f
IMU_update_sensors	imu.cpp	/^void IMU_update_sensors(void)$/;"	f
KD	pidcontroller.h	/^				double KD;$/;"	m	class:EPID
KI	pidcontroller.h	/^				double KI;$/;"	m	class:EPID
KP	pidcontroller.h	/^				double KP;$/;"	m	class:EPID
LPFRC	rc.cpp	/^static int32_t LPFRC[CHANNELS] = {$/;"	v	file:
LPF_RC_FACTOR	rc.h	10;"	d
MOTORS_H	motors.h	2;"	d
Motors_control	eboxcopter.cpp	/^void Motors_control(void)$/;"	f
Motors_flush	motors.cpp	/^void Motors_flush(int motor1,$/;"	f
Motors_init	motors.cpp	/^void Motors_init(void)$/;"	f
Motors_start	motors.cpp	/^void Motors_start(int idlespeed)$/;"	f
Motors_stop	motors.cpp	/^void Motors_stop(void)$/;"	f
PA6	rc.cpp	/^static IN_CAPTURE RcCh1(&PA6);$/;"	v	file:
PA7	rc.cpp	/^static IN_CAPTURE RcCh2(&PA7);$/;"	v	file:
PB0	rc.cpp	/^static IN_CAPTURE RcCh3(&PB0);$/;"	v	file:
PB1	rc.cpp	/^static IN_CAPTURE RcCh4(&PB1);$/;"	v	file:
PIDCONTROLLER_H	pidcontroller.h	2;"	d
PITCH	rc.h	/^		PITCH = 1,$/;"	e	enum:__anon2
PITCH_ZERO	rc.h	12;"	d
RCANGLE	rc.cpp	/^ double RCANGLE[CHANNELS] = {$/;"	v
RCDATA	rc.cpp	/^ int32_t RCDATA[CHANNELS] = {$/;"	v
RC_H	rc.h	2;"	d
RC_init	rc.cpp	/^void RC_init(void)$/;"	f
RCdata_compute	rc.cpp	/^void RCdata_compute(void)$/;"	f
ROLL	rc.h	/^		ROLL = 0,$/;"	e	enum:__anon2
ROLL_ZERO	rc.h	11;"	d
Rate_control	eboxcopter.cpp	/^void Rate_control(void)$/;"	f
SENSOR_MAX_G	imu.cpp	104;"	d	file:
SENSOR_MAX_W	imu.cpp	105;"	d	file:
THROTTLE	rc.h	/^		THROTTLE = 3$/;"	e	enum:__anon2
THROTTLE_ZERO	rc.h	13;"	d
TIMER_H_	timer.h	2;"	d
Timer_init	timer.cpp	/^void Timer_init(void)$/;"	f
X	imu.h	/^		X,$/;"	e	enum:__anon1
Y	imu.h	/^		Y,$/;"	e	enum:__anon1
YAW	rc.h	/^		YAW = 2,$/;"	e	enum:__anon2
YAW_RATE_MAX	rc.h	8;"	d
YAW_ZERO	rc.h	14;"	d
Z	imu.h	/^		Z$/;"	e	enum:__anon1
a1	filter.h	/^				double a1;$/;"	m	class:ELPF
a2	filter.h	/^				double a2;$/;"	m	class:ELPF
accADC	imu.h	/^		int16_t accADC[3];$/;"	m	struct:imu_tt
accOffset	imu.h	/^		float   accOffset[3];		\/\/m\/s^2$/;"	m	struct:imu_tt
accRaw	imu.h	/^		float 	accRaw[3];		\/\/m\/s^2$/;"	m	struct:imu_tt
acc_x_lpf	imu.cpp	/^ELPF    acc_x_lpf;$/;"	v
acc_y_lpf	imu.cpp	/^ELPF    acc_y_lpf;$/;"	v
acc_z_lpf	imu.cpp	/^ELPF    acc_z_lpf;$/;"	v
accb	imu.h	/^		float   accb[3];		\/\/filted, in body frame$/;"	m	struct:imu_tt
accg	imu.h	/^		float   accg[3];$/;"	m	struct:imu_tt
apply	filter.cpp	/^double ELPF::apply(double sample)$/;"	f	class:ELPF
b0	filter.h	/^				double b0;$/;"	m	class:ELPF
b1	filter.h	/^				double b1;$/;"	m	class:ELPF
b2	filter.h	/^				double b2;$/;"	m	class:ELPF
bFilterInit	estimate.cpp	/^static uint8_t bFilterInit = 0;$/;"	v	file:
caliPass	imu.h	/^		uint8_t caliPass;$/;"	m	struct:imu_tt
chan1_mesure_frq	rc.cpp	/^void chan1_mesure_frq(void)\/\/输入捕获中断事件$/;"	f
chan2_mesure_frq	rc.cpp	/^void chan2_mesure_frq(void)\/\/输入捕获中断事件$/;"	f
chan3_mesure_frq	rc.cpp	/^void chan3_mesure_frq(void)\/\/输入捕获中断事件$/;"	f
chan4_mesure_frq	rc.cpp	/^void chan4_mesure_frq(void)\/\/输入捕获中断事件$/;"	f
compute	pidcontroller.cpp	/^double EPID::compute(double input, uint64_t deltatime)$/;"	f	class:EPID
compute	pidcontroller.cpp	/^void EPID::compute(double input, double& output, uint64_t deltatime)$/;"	f	class:EPID
compute	pidcontroller.cpp	/^void EPID::compute(double setpoint, double input, double& output)$/;"	f	class:EPID
cutoff_frequency	filter.h	/^				double cutoff_frequency;$/;"	m	class:ELPF
delay_element_0	filter.h	/^				double delay_element_0;$/;"	m	class:ELPF
delay_element_1	filter.h	/^				double delay_element_1;$/;"	m	class:ELPF
delay_element_2	filter.h	/^				double delay_element_2;$/;"	m	class:ELPF
delta_time	pidcontroller.h	/^				uint64_t delta_time;$/;"	m	class:EPID
derivative	pidcontroller.h	/^				double derivative;$/;"	m	class:EPID
dq0	estimate.cpp	/^static float dq0 = 0.0f, dq1 = 0.0f, dq2 = 0.0f, dq3 = 0.0f;	$/;"	v	file:
dq1	estimate.cpp	/^static float dq0 = 0.0f, dq1 = 0.0f, dq2 = 0.0f, dq3 = 0.0f;	$/;"	v	file:
dq2	estimate.cpp	/^static float dq0 = 0.0f, dq1 = 0.0f, dq2 = 0.0f, dq3 = 0.0f;	$/;"	v	file:
dq3	estimate.cpp	/^static float dq0 = 0.0f, dq1 = 0.0f, dq2 = 0.0f, dq3 = 0.0f;	$/;"	v	file:
error	pidcontroller.h	/^				double error;$/;"	m	class:EPID
eular2DCM	imu.cpp	/^static void eular2DCM(float DCM[3][3],float roll,float pitch,float yaw) $/;"	f	file:
fracfreq	rc.cpp	/^const int fracfreq = 1;$/;"	v
get_deltatime	pidcontroller.cpp	/^double EPID::get_deltatime()$/;"	f	class:EPID
get_derivative	pidcontroller.cpp	/^double EPID::get_derivative()$/;"	f	class:EPID
get_integral	pidcontroller.cpp	/^double EPID::get_integral()$/;"	f	class:EPID
get_kd	pidcontroller.cpp	/^double EPID::get_kd()$/;"	f	class:EPID
get_ki	pidcontroller.cpp	/^double EPID::get_ki()$/;"	f	class:EPID
get_kp	pidcontroller.cpp	/^double EPID::get_kp()$/;"	f	class:EPID
get_minsample_time	pidcontroller.cpp	/^double EPID::get_minsample_time()$/;"	f	class:EPID
get_output	pidcontroller.cpp	/^double EPID::get_output()$/;"	f	class:EPID
get_proportional	pidcontroller.cpp	/^double EPID::get_proportional()$/;"	f	class:EPID
get_setpoint	pidcontroller.cpp	/^double EPID::get_setpoint()$/;"	f	class:EPID
gyro	imu.h	/^		float   gyro[3];$/;"	m	struct:imu_tt
gyroADC	imu.h	/^		int16_t gyroADC[3];$/;"	m	struct:imu_tt
gyroOffset	imu.h	/^		float   gyroOffset[3]; $/;"	m	struct:imu_tt
gyroRaw	imu.h	/^		float 	gyroRaw[3];		\/\/rad\/s $/;"	m	struct:imu_tt
gyro_bias	estimate.cpp	/^static float gyro_bias[3] = {0.0f, 0.0f, 0.0f}; $/;"	v	file:
gyro_x_lpf	imu.cpp	/^ELPF    gyro_x_lpf;$/;"	v
gyro_y_lpf	imu.cpp	/^ELPF    gyro_y_lpf;$/;"	v
gyro_z_lpf	imu.cpp	/^ELPF    gyro_z_lpf;$/;"	v
i2c2	imu.cpp	/^MPU6050 mpu(&i2c2);$/;"	v
ic_chan1_high	rc.cpp	/^static uint32_t ic_chan1_high;$/;"	v	file:
ic_chan1_low	rc.cpp	/^static uint32_t ic_chan1_low;$/;"	v	file:
ic_chan2_high	rc.cpp	/^static uint32_t ic_chan2_high;$/;"	v	file:
ic_chan2_low	rc.cpp	/^static uint32_t ic_chan2_low;$/;"	v	file:
ic_chan3_high	rc.cpp	/^static uint32_t ic_chan3_high;$/;"	v	file:
ic_chan3_low	rc.cpp	/^static uint32_t ic_chan3_low;$/;"	v	file:
ic_chan4_high	rc.cpp	/^static uint32_t ic_chan4_high;$/;"	v	file:
ic_chan4_low	rc.cpp	/^static uint32_t ic_chan4_low;$/;"	v	file:
imu	imu.cpp	/^imu_t	imu = {$/;"	v
imu_cali_flag	imu.cpp	/^uint8_t imu_cali_flag = 0;$/;"	v
imu_t	imu.h	/^}imu_t;$/;"	t	typeref:struct:imu_tt
imu_tt	imu.h	/^typedef struct imu_tt$/;"	s
input	pidcontroller.h	/^				double input;$/;"	m	class:EPID
integ_limit	pidcontroller.h	/^				double integ_limit;$/;"	m	class:EPID
integral	pidcontroller.h	/^				double integral;$/;"	m	class:EPID
inv_sqrt	estimate.cpp	/^static float inv_sqrt(float number) $/;"	f	file:
last_time	pidcontroller.h	/^				uint64_t last_time;	\/\/in us;$/;"	m	class:EPID
loop_100HZ_count	timer.cpp	/^volatile int  loop_100HZ_count = 0;$/;"	v
loop_100HZ_flag	timer.cpp	/^bool loop_100HZ_flag = false;$/;"	v
loop_100HZ_overhead	timer.cpp	/^const int	loop_100HZ_overhead = 1000 \/ 100;$/;"	v
loop_50HZ_count	timer.cpp	/^volatile int  loop_50HZ_count = 0;$/;"	v
loop_50HZ_flag	timer.cpp	/^bool loop_50HZ_flag = false;$/;"	v
loop_50HZ_overhead	timer.cpp	/^const int	loop_50HZ_overhead = 1000 \/ 50;$/;"	v
magADC	imu.h	/^		int16_t magADC[3];$/;"	m	struct:imu_tt
magRaw	imu.h	/^		float 	magRaw[3];		\/\/$/;"	m	struct:imu_tt
main	eboxcopter.cpp	/^int main()$/;"	f
max_output	pidcontroller.h	/^				double max_output;$/;"	m	class:EPID
min_output	pidcontroller.h	/^				double min_output;$/;"	m	class:EPID
min_sample_time	pidcontroller.h	/^				uint64_t min_sample_time;$/;"	m	class:EPID
motors	motors.cpp	/^PWM motors[4] = {$/;"	v
offset	rc.cpp	/^const int offset   = 168;$/;"	v
output	filter.h	/^				double output;$/;"	m	class:ELPF
output	pidcontroller.h	/^				double output;$/;"	m	class:EPID
pitch	imu.h	/^		float   pitch;$/;"	m	struct:imu_tt
pitchRad	imu.h	/^		float   pitchRad;$/;"	m	struct:imu_tt
pitch_pidoutput	eboxcopter.cpp	/^static double pitch_pidoutput;$/;"	v	file:
pre_error	pidcontroller.h	/^				double pre_error;$/;"	m	class:EPID
prepre_error	pidcontroller.h	/^				double prepre_error;$/;"	m	class:EPID
proportional	pidcontroller.h	/^				double proportional;$/;"	m	class:EPID
q	imu.h	/^		float   q[4];$/;"	m	struct:imu_tt
q0	estimate.cpp	/^static float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;	$/;"	v	file:
q0q0	estimate.cpp	/^static float q0q0, q0q1, q0q2, q0q3;$/;"	v	file:
q0q1	estimate.cpp	/^static float q0q0, q0q1, q0q2, q0q3;$/;"	v	file:
q0q2	estimate.cpp	/^static float q0q0, q0q1, q0q2, q0q3;$/;"	v	file:
q0q3	estimate.cpp	/^static float q0q0, q0q1, q0q2, q0q3;$/;"	v	file:
q1	estimate.cpp	/^static float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;	$/;"	v	file:
q1q1	estimate.cpp	/^static float q1q1, q1q2, q1q3;$/;"	v	file:
q1q2	estimate.cpp	/^static float q1q1, q1q2, q1q3;$/;"	v	file:
q1q3	estimate.cpp	/^static float q1q1, q1q2, q1q3;$/;"	v	file:
q2	estimate.cpp	/^static float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;	$/;"	v	file:
q2q2	estimate.cpp	/^static float q2q2, q2q3;$/;"	v	file:
q2q3	estimate.cpp	/^static float q2q2, q2q3;$/;"	v	file:
q3	estimate.cpp	/^static float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f;	$/;"	v	file:
q3q3	estimate.cpp	/^static float q3q3;$/;"	v	file:
ready	imu.h	/^		uint8_t ready;$/;"	m	struct:imu_tt
reset	filter.cpp	/^void ELPF::reset(double sample_freq, double cutoff_freq)$/;"	f	class:ELPF
roll	imu.h	/^		float   roll;				\/\/deg$/;"	m	struct:imu_tt
rollRad	imu.h	/^		float   rollRad;				\/\/rad$/;"	m	struct:imu_tt
roll_pidoutput	eboxcopter.cpp	/^static double roll_pidoutput;$/;"	v	file:
sample_frequency	filter.h	/^				double sample_frequency;$/;"	m	class:ELPF
set_cutoff_frequency	filter.cpp	/^void ELPF::set_cutoff_frequency(double cutoff_freq)$/;"	f	class:ELPF
set_integral_limit	pidcontroller.cpp	/^void EPID::set_integral_limit(double limit)$/;"	f	class:EPID
set_minsample_time	pidcontroller.cpp	/^void EPID::set_minsample_time(uint64_t sampletime)$/;"	f	class:EPID
set_output_limits	pidcontroller.cpp	/^void EPID::set_output_limits(double min, double max)$/;"	f	class:EPID
set_pid	pidcontroller.cpp	/^void EPID::set_pid(double kp, double ki, double kd)$/;"	f	class:EPID
set_point	pidcontroller.cpp	/^void EPID::set_point(double setpoint)$/;"	f	class:EPID
set_sample_frequency	filter.cpp	/^void ELPF::set_sample_frequency(double sample_freq)$/;"	f	class:ELPF
setpoint	pidcontroller.h	/^				double setpoint;$/;"	m	class:EPID
setup	eboxcopter.cpp	/^void setup(void)$/;"	f
so3_comp_params_Ki	estimate.cpp	6;"	d	file:
so3_comp_params_Kp	estimate.cpp	5;"	d	file:
throttle_output	eboxcopter.cpp	/^static double throttle_output;$/;"	v	file:
update_counter	timer.cpp	/^void update_counter(void)$/;"	f
yaw	imu.h	/^		float 	yaw;$/;"	m	struct:imu_tt
yawRad	imu.h	/^		float 	yawRad;$/;"	m	struct:imu_tt
yaw_pitdoutput	eboxcopter.cpp	/^static double yaw_pitdoutput;$/;"	v	file:
